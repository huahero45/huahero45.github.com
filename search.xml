<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双亲委派</title>
      <link href="/classloader.html"/>
      <url>/classloader.html</url>
      
        <content type="html"><![CDATA[<h2 id="双亲委派机制的工作原理"><a href="#双亲委派机制的工作原理" class="headerlink" title="双亲委派机制的工作原理"></a>双亲委派机制的工作原理</h2><p>1） 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</p><p>2） 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</p><p>3） 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p><p><img src="/img/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="双亲委派机制"></p><h2 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a>双亲委派机制的作用</h2><p>1） 避免类的重复加载</p><p>2） 保护程序安全，防止核心API被随意篡改,如</p><pre><code>        自定义类：java.lang.String        自定义类：java.lang.huahero</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层实现</title>
      <link href="/hashmap.html"/>
      <url>/hashmap.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。</p><p>从JDK1.8开始，HashMap 底层是 数组+链表 或 数组+红黑树，当链表长度大于阈值(默认为8)时，将链表转化为红黑树，以减少搜索时间。</p><p>HashMap 通过 key 的 hashCode 经过扰动函数(即 HashMap的 hash() 方法)处理过后得到 hash 值，然后通过(n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 </p><p>所谓扰动函数指的就是 HashMap 的 hash() 方法。使用 hash() 方法是为了防止一些实现比较差的hashCode() 方法, 从而可以减少碰撞。</p><p>一般面试中只要回答以上就好了，如果自己还要加深理解的话可以参考这篇博文<br><a href="https://blog.csdn.net/sinat_33921105/article/details/103344078" target="_blank" rel="noopener">https://blog.csdn.net/sinat_33921105/article/details/103344078</a></p><p>位运算符 和 除模取余运算符 之间的关系:<br>    (n-1) &amp; hash =  hash % n<br>    前提: n 必须是 2的n次幂</p><h2 id="JDK-1-8-HashMap-的-hash-方法源码"><a href="#JDK-1-8-HashMap-的-hash-方法源码" class="headerlink" title="JDK 1.8 HashMap 的 hash 方法源码:"></a>JDK 1.8 HashMap 的 hash 方法源码:</h2><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> h<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode </span>    <span class="token comment" spellcheck="true">// ^ ：按位异或 </span>    <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐 </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JDK-1-7的-HashMap-的-hash-方法源码"><a href="#JDK-1-7的-HashMap-的-hash-方法源码" class="headerlink" title="JDK 1.7的 HashMap 的 hash 方法源码:"></a>JDK 1.7的 HashMap 的 hash 方法源码:</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by </span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded </span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor). </span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。<br><img src="/img/hashmap/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8.png" alt="1.7之前是数组+链表"></p><p>JDK1.8之后<br>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/img/hashmap/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="1.8之后是数组+链表/红黑树"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/lock.html"/>
      <url>/lock.html</url>
      
        <content type="html"><![CDATA[<h1 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h1><p><a href="https://github.com/redisson/redisson/wiki/1.-Overview" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/1.-Overview</a> </p><h2 id="1）、简介"><a href="#1）、简介" class="headerlink" title="1）、简介"></a>1）、简介</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="2）、整合"><a href="#2）、整合" class="headerlink" title="2）、整合"></a>2）、整合</h2><p>引入pom</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mvnrepository<span class="token punctuation">.</span>com<span class="token operator">/</span>artifact<span class="token operator">/</span>org<span class="token punctuation">.</span>redisson<span class="token operator">/</span>redisson <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>redisson<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>redisson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.10</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置</p><pre class="line-numbers language-java"><code class="language-java">spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>host<span class="token operator">=</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">159.130</span>spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GmallRedissonConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.redis.host}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String host<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.redis.port}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedissonClient <span class="token function">redissonClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://"</span><span class="token operator">+</span>host<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        RedissonClient redisson <span class="token operator">=</span> Redisson<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> redisson<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3）、锁机制"><a href="#3）、锁机制" class="headerlink" title="3）、锁机制"></a>3）、锁机制</h2><p>lock：可重入锁（最常用的锁？和synchronized有何不同？）<br>ReadWriteLock：读写锁（读共享，写互斥，写时不读）<br>Semaphore：信号量（停车场、acquire(1)占领一个车位,release()释放一个车位）<br>CountDownLatch：闭锁（班长最后一个关灯走人。。。）</p><h3 id="1、可重入锁（Reentrant-Lock）"><a href="#1、可重入锁（Reentrant-Lock）" class="headerlink" title="1、可重入锁（Reentrant Lock）"></a>1、可重入锁（Reentrant Lock）</h3><p>基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><pre class="line-numbers language-java"><code class="language-java">RLock lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"anyLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``` <span class="token comment" spellcheck="true">// 最常见的使用方法，如果获取不到锁会一直自旋下去等待获取到锁</span>``` javalock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>``` 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。``` java<span class="token comment" spellcheck="true">// 加锁以后10秒钟自动解锁</span><span class="token comment" spellcheck="true">// 可以无需调用unlock方法手动解锁</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁；如果没有等待时间，锁不住直接返回false</span><span class="token keyword">boolean</span> res <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">try</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>       lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、公平锁（Fair-Lock）"><a href="#2、公平锁（Fair-Lock）" class="headerlink" title="2、公平锁（Fair Lock）"></a>2、公平锁（Fair Lock）</h3><p>它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p><pre class="line-numbers language-java"><code class="language-java">RLock fairLock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getFairLock</span><span class="token punctuation">(</span><span class="token string">"anyLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最常见的使用方法</span>fairLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 10秒钟以后自动解锁</span><span class="token comment" spellcheck="true">// 无需调用unlock方法手动解锁</span>fairLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><span class="token keyword">boolean</span> res <span class="token operator">=</span> fairLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>fairLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、联锁（MultiLock）"><a href="#3、联锁（MultiLock）" class="headerlink" title="3、联锁（MultiLock）"></a>3、联锁（MultiLock）</h3><p>基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。</p><pre class="line-numbers language-java"><code class="language-java">RLock lock1 <span class="token operator">=</span> redissonInstance1<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RLock lock2 <span class="token operator">=</span> redissonInstance2<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RLock lock3 <span class="token operator">=</span> redissonInstance3<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RedissonMultiLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonMultiLock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">,</span> lock3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同时加锁：lock1 lock2 lock3</span><span class="token comment" spellcheck="true">// 所有的锁都上锁成功才算成功。</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、红锁（RedLock）"><a href="#4、红锁（RedLock）" class="headerlink" title="4、红锁（RedLock）"></a>4、红锁（RedLock）</h3><p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。</p><pre class="line-numbers language-java"><code class="language-java">RLock lock1 <span class="token operator">=</span> redissonInstance1<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RLock lock2 <span class="token operator">=</span> redissonInstance2<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RLock lock3 <span class="token operator">=</span> redissonInstance3<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RedissonRedLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonRedLock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">,</span> lock3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同时加锁：lock1 lock2 lock3</span><span class="token comment" spellcheck="true">// 红锁在大部分节点上加锁成功就算成功。</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>RedissonRedLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonRedLock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">,</span> lock3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开</span><span class="token keyword">boolean</span> res <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、读写锁（ReadWriteLock）"><a href="#5、读写锁（ReadWriteLock）" class="headerlink" title="5、读写锁（ReadWriteLock）"></a>5、读写锁（ReadWriteLock）</h3><p>基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock接口。<br>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p><pre class="line-numbers language-java"><code class="language-java">RReadWriteLock rwlock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getReadWriteLock</span><span class="token punctuation">(</span><span class="token string">"anyRWLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最常见的使用方法</span>rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 或</span>rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 10秒钟以后自动解锁</span><span class="token comment" spellcheck="true">// 无需调用unlock方法手动解锁</span>rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 或</span>rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><span class="token keyword">boolean</span> res <span class="token operator">=</span> rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 或</span><span class="token keyword">boolean</span> res <span class="token operator">=</span> rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、信号量（Semaphore）"><a href="#6、信号量（Semaphore）" class="headerlink" title="6、信号量（Semaphore）"></a>6、信号量（Semaphore）</h3><p>基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><pre class="line-numbers language-java"><code class="language-java">RSemaphore semaphore <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getSemaphore</span><span class="token punctuation">(</span><span class="token string">"semaphore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或</span>semaphore<span class="token punctuation">.</span><span class="token function">acquireAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或</span>semaphore<span class="token punctuation">.</span><span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或</span>semaphore<span class="token punctuation">.</span><span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或</span>semaphore<span class="token punctuation">.</span><span class="token function">releaseAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、可过期性信号量（PermitExpirableSemaphore）"><a href="#7、可过期性信号量（PermitExpirableSemaphore）" class="headerlink" title="7、可过期性信号量（PermitExpirableSemaphore）"></a>7、可过期性信号量（PermitExpirableSemaphore）</h3><p>基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。它提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><pre class="line-numbers language-java"><code class="language-java">RPermitExpirableSemaphore semaphore <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getPermitExpirableSemaphore</span><span class="token punctuation">(</span><span class="token string">"mySemaphore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String permitId <span class="token operator">=</span> semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取一个信号，有效期只有2秒钟。</span>String permitId <span class="token operator">=</span> semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ...</span>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>permitId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、闭锁（CountDownLatch）"><a href="#8、闭锁（CountDownLatch）" class="headerlink" title="8、闭锁（CountDownLatch）"></a>8、闭锁（CountDownLatch）</h3><p>基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。</p><pre class="line-numbers language-java"><code class="language-java">RCountDownLatch latch <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getCountDownLatch</span><span class="token punctuation">(</span><span class="token string">"anyCountDownLatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>latch<span class="token punctuation">.</span><span class="token function">trySetCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在其他线程或其他JVM里</span>RCountDownLatch latch <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getCountDownLatch</span><span class="token punctuation">(</span><span class="token string">"anyCountDownLatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>土豪富婆进来看看</title>
      <link href="/donate.html"/>
      <url>/donate.html</url>
      
        <content type="html"><![CDATA[<h2 id="嘿嘿"><a href="#嘿嘿" class="headerlink" title="嘿嘿"></a>嘿嘿</h2><p><img src="https://cdn.jsdelivr.net/gh/huahero45/cdn@1.0/alipayQR.jpg" alt="谢谢有钱的淫"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 打赏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菊花宝典</title>
      <link href="/juhuabaodian.html"/>
      <url>/juhuabaodian.html</url>
      
        <content type="html"><![CDATA[<h2 id="武功秘籍"><a href="#武功秘籍" class="headerlink" title="武功秘籍"></a>武功秘籍</h2><p><img src="/img/%E5%96%9C%E6%AC%A2/2.jpg" alt=""><br>欲练此功,必先自宫！<br>如不自宫,也可成功！<br>若已自宫,未必成功！<br>如想成功,来世用功!!!!</p>]]></content>
      
      
      
        <tags>
            
            <tag> 偏门技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/thread.html"/>
      <url>/thread.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于线程池"><a href="#1-关于线程池" class="headerlink" title="1.关于线程池"></a>1.关于线程池</h2><pre><code>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。好处：1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。      2.提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。      3.提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</code></pre><p>Java中的线程池核心实现类是ThreadPoolExecutor，这里基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。<br><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadPoolExecutor%E7%9A%84UML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutor UML类图"><br>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：<br><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程"><br>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。<br><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="线程池的执行流程"></p><h2 id="2-线程池的作用"><a href="#2-线程池的作用" class="headerlink" title="2.线程池的作用"></a>2.线程池的作用</h2><pre><code>    线程池是为突然大量爆发的线程设计的，通过有限的几个固定线程为大量的操作服务，减少了创建和销毁线程所需的时间，从而提高效率。    如果一个线程的时间非常长，就没必要用线程池了(不是不能作长时间操作，而是不宜。)，况且我们还不能控制线程池中线程的开始、挂起、和中止。</code></pre><h2 id="3-线程池的使用方式"><a href="#3-线程池的使用方式" class="headerlink" title="3.线程池的使用方式"></a>3.线程池的使用方式</h2><h3 id="3-1-使用ThreadPoolExecutor-面试重点"><a href="#3-1-使用ThreadPoolExecutor-面试重点" class="headerlink" title="3.1.使用ThreadPoolExecutor(面试重点)"></a>3.1.使用ThreadPoolExecutor(面试重点)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用示例</span>ExecutorService pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>         <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ThreadPoolExecutor构造方法</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//核心池的大小</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">// maximumPoolSize：线程池最大线程数</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">//存活时间</span>                          TimeUnit unit<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//存活时间单位</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//阻塞队列</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//线程工厂，用于创建线程</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//拒绝策略</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>                null <span class="token operator">:</span>                AccessController<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-1-ThreadPoolExecutor构造函数的参数"><a href="#3-1-1-ThreadPoolExecutor构造函数的参数" class="headerlink" title="3.1.1.ThreadPoolExecutor构造函数的参数"></a>3.1.1.ThreadPoolExecutor构造函数的参数</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span> corePoolSize：核心池的大小。不管它们创建以后是不是空闲的，线程池需要保持corePoolSize数量的线程，除非设置了allowCoreThreadTimeOut<span class="token number">2</span><span class="token punctuation">.</span> maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程<span class="token number">3</span><span class="token punctuation">.</span> keepAliveTime：存活时间，如果经过keepAliveTime时间后，超过核心线程数的线程还没有接收到新的任务，那就回收<span class="token number">4</span><span class="token punctuation">.</span> unit：参数keepAliveTime的时间单位，有<span class="token number">7</span>种取值，在TimeUnit类中有<span class="token number">7</span>种静态属性<span class="token number">5</span><span class="token punctuation">.</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue：阻塞队列<span class="token operator">:</span>当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被execute方法提交的Runnable任务。所以这里就不要翻译为工作队列！<span class="token number">6</span><span class="token punctuation">.</span> ThreadFactory threadFactory：生成线程的工厂，这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼<span class="token number">7</span><span class="token punctuation">.</span> RejectedExecutionHandler handler：拒绝策略：当阻塞队列里放满了任务、最大线程数的线程都在工作时，这时继续提交多的任务线程池就处理不了，应该执行怎样的拒绝策略。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-2-拒绝策略"><a href="#3-1-2-拒绝策略" class="headerlink" title="3.1.2.拒绝策略"></a>3.1.2.拒绝策略</h4><pre class="line-numbers language-java"><code class="language-java">JDK提供的<span class="token number">4</span>种拒绝策略如下（即 RejectedExecutionHandler 的<span class="token number">4</span>种实现类）：<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span>；<span class="token comment" spellcheck="true">//丢弃任务 并 抛出 RejectedExecutionException 异常，这个是默认的处理策略。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span>；<span class="token comment" spellcheck="true">//如果线程池没有被关闭，就交由提交任务的线程来执行。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardOldestPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token comment" spellcheck="true">//丢弃阻塞队列里最早的任务，然后将这个新任务提交到阻塞队列中。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token comment" spellcheck="true">//丢弃任务，但是不抛出异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-3-阻塞队列"><a href="#3-1-3-阻塞队列" class="headerlink" title="3.1.3.阻塞队列"></a>3.1.3.阻塞队列</h4><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：<br><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列"></p><p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：<br><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E6%88%90%E5%91%98.png" alt="阻塞队列的成员"></p><h3 id="3-2-Executors创建线程池"><a href="#3-2-Executors创建线程池" class="headerlink" title="3.2.Executors创建线程池"></a>3.2.Executors创建线程池</h3><p>不推荐使用这种方式，实际工作中用的是以上的 ThreadPoolExecutor 来自定义线程池</p><p>例： Executors. newFixedThreadPool();</p><pre><code>1.newCachedThreadPool：    创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。2.newFixedThreadPool：    创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。3.newScheduledThreadPool：    创建一个定长线程池，支持定时及周期性任务执行。4.newSingleThreadExecutor：    创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。5.newCachedThreadPool    创建可缓存线程池，线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。6.newFixedThreadPool    创建一个定长线程池，可控制线程最大并发数，因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置。7.newScheduledThreadPool    创建一个定长线程池，支持定时及周期性任务执行。8.newSingleThreadExecutor    创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成功人士</title>
      <link href="/shapa.html"/>
      <url>/shapa.html</url>
      
        <content type="html"><![CDATA[<h2 id="傻帕"><a href="#傻帕" class="headerlink" title="傻帕"></a>傻帕</h2><p><img src="/img/%E5%82%BB%E5%BD%AA/%E8%8F%9C%E6%A4%92.jpg" alt="那个椒妇科主任医生"><br><img src="/img/%E5%82%BB%E5%BD%AA/%E7%8C%AA%E5%93%A5.jpg" alt="那个“萌妹”"><br><img src="/img/%E5%82%BB%E5%BD%AA/%E8%82%89%E6%9D%BE%E5%90%9B.jpg" alt="国企高管松下基层..."></p>]]></content>
      
      
      
        <tags>
            
            <tag> 傻彪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>萌妹</title>
      <link href="/menmei.html"/>
      <url>/menmei.html</url>
      
        <content type="html"><![CDATA[<h2 id="好湿！"><a href="#好湿！" class="headerlink" title="好湿！"></a>好湿！</h2><p><img src="/img/%E5%96%9C%E6%AC%A2/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%AB%98%E6%B8%85.png" alt="萌妹镇楼"><br>天增岁月人增寿，<br>春满乾坤福满堂！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 萌妹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好看滴妹纸</title>
      <link href="/beauty.html"/>
      <url>/beauty.html</url>
      
        <content type="html"><![CDATA[<h2 id="Beauty"><a href="#Beauty" class="headerlink" title="Beauty"></a>Beauty</h2><p><img src="/img/%E5%A6%B9%E7%BA%B8/%E5%A6%B9%E7%BA%B8.png" alt="PANPAN"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 萌妹 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
